# -*- coding: utf-8 -*-
"""
Created on Wed Sep 25 14:31:57 2024

@author: dliu8
"""

# =============================================================================
# this py code represent ths DSO, which is a prover
# successfully on 27/09/2024
# =============================================================================

import zmq
import random
import time
import Pedersen_0 as P
import json
import numpy as np


# -----------------------------------------------------------------------------
def create_commit(pedersen, p, g, h, m):
    r = random.randint(1, p-1)
    
    # Create to scalar points on the curve
    mg = pedersen.cp.mul_point(m, g)
    rh = pedersen.cp.mul_point(r, h)

    # # Commitment which is the two points on the curve
    c = pedersen.cp.add_point(mg, rh) # Combine points (mod p is inherently respected in elliptic curve operations)

    return c, r

def convert_to_json(data):
    data_dict = {'x': data.x, 'y': data.y}
    json_data = json.dumps(data_dict)
    
    return json_data

def combinations(k):
    return list((i, j) for i in range(k+1) for j in range(i+1, k+1))

def combinations_of_three(k):
    return list((i, j, m) for i in range(k+1) for j in range(i+1, k+1) for m in range(j+1, k+1))

def combinations_of_four(k):
    result = []
    for i in range(k+1):
        for j in range(i+1, k+1):
            for m in range(j+1, k+1):
                for n in range(m+1, k+1):
                    result.append((i, j, m, n))
    return result


# -----------------------------------------------------------------------------
# setting for communication
port = "5556"                                   # Defines the port to use for the socket communication.
context = zmq.Context()                         # Create a ZeroMQ context (an environment for sockets)
socket = context.socket(zmq.PAIR)               # Create a PAIR socket (for two-way communication)
socket.bind("tcp://*:%s" % port)                # Bind the socket to port 5556 for communication

# =============================================================================
# # to close the port by cmd 
# netstat -ano | findstr 5556 
# taskkill /PID 11208 /F
# =============================================================================

send = socket.send_json                         # Function to send data in JSON format
recv = socket.recv_json                         # Function to receive data in JSON format

# -----------------------------------------------------------------------------

# N = 90
time_l = 96*30

sm_data = np.zeros((90, time_l))

# sm_ind = []

time0 = [] 
NN = 20
for tk in range(1):

    for N in range(NN, NN+10, 10):
        start_time = time.time()
        #------ZKP---------------------------------------------------------------------
        for t in range(0, N):
            
            #------------------------------------------------------------------------------
            # 创建 Pedersen Commitment 
            pedersen = P.Pedersen_0()
            p, g, h = pedersen.param  
        
            g1 = convert_to_json(g)
            h1 = convert_to_json(h)
            send((p, g1, h1))   
        
            #------------------------------------------------------------------------------  
    
            k = recv()
            list_com = combinations(k-1)     # generate the combination of the 2 out of k
            # list_com = combinations_of_three(k-1)
            # list_com = combinations_of_four(k-1)
            # list_com = [tuple(map(lambda x: x + 1, tup)) for tup in list_com]

            
            for i in range(0, len(list_com)):
                # print(i)
                # 要提交的消息
                # send((int(list_com[i][0]), int(list_com[i][1])))    # since SM know the data so the data should be shared with SM
                
                c1, r1 = create_commit(pedersen, p, g, h, list_com[i][0] + p)
                c11 = convert_to_json(c1)
                send(c11)
                c2, r2 = create_commit(pedersen, p, g, h, list_com[i][1] + p)
                c21 = convert_to_json(c2)
                send(c21)
                
                # c3, r3 = create_commit(pedersen, p, g, h, list_com[i][2] + p)
                # c31 = convert_to_json(c3)
                # send(c31)
                
                # c4, r4 = create_commit(pedersen, p, g, h, list_com[i][3] + p)
                # c41 = convert_to_json(c4)
                # send(c41)
                
                                
                
                # Verifier's challenge (b) generated by prover
                # b = random.choice([0, 1])
                # send(b)
                b = recv()
                
                # Prover's response
                if b == 0:
                    s1 = r1
                    s2 = (r2 + (1-b) * list_com[i][1]) % p 
                    # s3 = r3
                    # s4 = (r4 + (1-b) * list_com[i][3]) % p 
                else:
                    s1 = (r1 + b * list_com[i][0]) % p 
                    s2 = r2
                    # s3 = (r3 + b * list_com[i][2]) % p 
                    # s4 = r4
                
                send((s1, s2))
                # send((s1, s2, s3))
                # send((s1, s2, s3, s4))
             
            
                msg = recv()
                if msg == "exit":
                    # sm_ind.append([t, list_com[i][0], list_com[i][1]])
                    
                    # =============================================================================
                    # sending the SM dataset
                    # generate a distribution of uniform format 
                    # =============================================================================
        
                    for ii in range(0, time_l):
                        result = recv()
                        sm_data[t][ii] = (result[list_com[i][0]] + result[list_com[i][1]])
                        # sm_data[t][ii] = (result[list_com[i][0]] + result[list_com[i][1]] + result[list_com[i][2]] + result[list_com[i][3]])
                    sm_data[t] = sm_data[t]/10000
                    
                    break
                
        end_time = time.time()
        execution_time = end_time - start_time
        time0.append(execution_time)
        print("代码运行时间为：", execution_time, "s")
        
            
time0 = np.array(time0)
data_to_send = time0.tolist()
send(data_to_send)



















